<!doctype html>
<html>
  <head>
    <!-- foo -->
    <meta charset="UTF-8">
    <title>Input Method Editor API</title>
    <style>
      body {
        counter-reset: figcaption;
        counter-reset: example;
      }
      figcaption {
        font-weight: bold;
      }
      figcaption:before {
        font-weight: bold;
        content: "Figure " counter(figcaption) ": ";
        counter-increment: figcaption;
      }
      var {
        font-weight: bold;
        color: green; 
        padding-left: 2px;
        padding-right: 4px;
      }
      .tocline {
        padding-top: 2px;
      }
      .ed_mailto:before {
        content: "<";
      }
      .ed_mailto:after {
        content: ">";
      }
    </style>
    <script class='remove'>
      function addEllipsis(id) {
        document.getElementById(id).childNodes.item(2).textContent = "\n    …\n";
      }
      function removeNodes(nodesToRemove) {
        var i, j;
        for (i = 0; i < nodesToRemove.length; ++i) {
          for (j = 0; j < nodesToRemove[i].length; ++j) {
            nodesToRemove[i][j].parentNode.removeChild(nodesToRemove[i][j]);
          }
        }
      }
    </script>
    <script class='remove'>
      function getLastModifiedDate() {
        var d = new Date(document.lastModified);
        return d.toISOString().substring(0,10);
      }
    </script>
    <script type="text/javascript" src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script type="text/javascript" class='remove'>
      var respecConfig = {
          specStatus: "ED",
          shortName:  "ime-api",
          edDraftURI: "http://dvcs.w3.org/hg/ime-api/raw-file/default/Overview.html",
          editors: [
                {   name:       "Hironori Bono (坊野 博典)",
                    company:    "Google",
                    mailto:     "hbono@google.com"
                },
                {   name:       "Kenji Baheux",
                    company:    "Google",
                    mailto:     "kenjibaheux@google.com"
                },
          ],
          extraCSS: [ "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css" ],
          wg:           "Web Applications Working Group",
          wgURI:        "http://www.w3.org/2008/webapps/",
          wgPublicList: "public-webapps",
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/42538/status",
          publishDate:  getLastModifiedDate(),
          after: function () {
            var nodesToRemove = [
              document.querySelectorAll("table.parameters"),
              document.querySelectorAll("li.tocline > a[href^='#attributes']"),
              document.querySelectorAll("li.tocline > a[href^='#methods']"),
            ];
            addEllipsis('idl-def-HTMLElement');
            removeNodes(nodesToRemove);
          }
      }
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>This specification defines an “IME API” that provides Web applications
      with scripted access to an IME (<a href="#IME">input-method editor</a>)
      associated with a hosting user agent. This IME API includes:</p>
      <ul>
       <li>An <a>InputMethodContext</a> interface, which provides methods to
        retrieve detailed data from an in-progress IME
        <a href="#ime-composition">composition</a>,
        and to update that data.</li>
       <li>A <a>Composition</a> dictionary, which represents read-only attributes
        about the current
        <a href="#ime-composition">composition</a>,
        such as the actual text being input, its length, and its target
        <a href="#clause">clause</a>.
        <p class="issue">need to define what a <i>clause</i> is</p></li>
      </ul>
      <p>This API is designed to be used in conjunction with DOM events and
      elements on the Web platform, notably: composition events and the
      <a href="http://dev.w3.org/html5/2dcontext/">Canvas 2D Context API</a>
      [[CANVAS-2D]].</p>
    </section>
    <section id='sotd'>
      <p>
        This document is a proposal that is being made available for public
        review in order to solicit feedback, particularly from
        implementors, with a goal of potential cross-browser implementation
        and standardization.
      </p>
    </section>
    <section class='informative' id="introduction">
      <h2>Introduction</h2>
      <p>Even though existing Web-platform APIs allow developers to implement very
      complicated Web applications, such as visual chat applications, using
      technologies such as SVG or the <code>&lt;canvas&gt;</code> element and API,
      developers have difficulties when implementing Web applications that
      control <a href="#IME">input-method editors</a>. To provide the
      ability for hosting user agents to expose Web applications to the
      <a href="#ime-composition">composition text</a>
      being composed in an associated IME,
      <a href="http://www.w3.org/TR/DOM-Level-3-Events/">the DOM Level 3 Events specification</a>
      [[DOM-LEVEL-3-EVENTS]]
      introduces <i>composition events</i>. Using composition events, Web
      applications can retrieve
      <a href="#ime-composition">composition text</a>
      from an IME.</p>

      <p>However, Web applications can still run into difficulties when
      they manipulate IMEs on non-editable elements such as the
      <code>&lt;canvas&gt;</code> element; those difficulties include the fact
      that a Web application cannot do the following:</p>

      <ul>
        <li>indicate to the user whether the Web application renders
        composition text by itself, or needs to ask user agents to render it</li>
        <li>determine the place where user agents render composition text</li>
        <li>detect whether the user agent renders
        <a href="#candidate-window">candidate windows</a>
        by themselves</li>
        <li>determine the place where user agents render
        <a href="#candidate-window">candidate windows</a></li>
      </ul>

      <p>The Web platform has a number of existing APIs useful for
      implementing a custom IME in JavaScript. For example, the Web Storage
      API can store an IME dictionary, and the WebSocket and XMLHttpRequest APIs
      allow sending a server request that performs a lookup in an IME dictionary,
      and so on. In fact, Web-application developers are already developing and
      deploying JavaScript-based IMEs that use these APIs. However, it is
      currently difficult to make those JavaScript-based IMEs work on all user
      agents, because they often rely on APIs specific to the hosting user agent,
      such as browser extension APIs.</p>

      <p>To solve these IME-related problems, this specification introduces
      an IME API that allows Web applications to read and write composition
      data made available by user agents. Moreover, this specification introduces
      interfaces for
      <a href="#ime-composition">compositions</a>,
      so Web applications can read detailed composition
      data and update it. A <a>Composition</a> object provides a reference
      to an ongoing IME
      <a href="#ime-composition">composition</a>,
      so Web applications can retrieve the composition text and attributes.</p>

      <p>The use of those APIs allows Web applications the ability to set the
      position of a <a href="#composition-window">composition window</a>
      and to retrieve the text and attributes of the ongoing
      <a href="#ime-composition">composition</a>.</p>

      <p>Consider the following examples. The first example shows the
      source for a Web application that renders composition text by itself
      and uses the
      <a href="#candidate-window">candidate window</a>
      provided by an IME.</p>
<pre class="example sh_javascript" id="ex-candidate-window">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script language="javascript" type="text/javascript"&gt;
function init() {
    document.getInputContext().setOpenState(true);
    var node = document.getElementById('canvas0');
    node.getInputContext().setEnable(true);
    node.addEventListener('compositionstart', onCompositionStart, false);
    node.addEventListener('compositionupdate', onCompositionUpdate, false);
    node.addEventListener('compositionend', onCompositionEnd, false);
}

function onCompositionStart(event) {
}

function onCompositionUpdate(event) {
    var x = 0;
    var y = 0;
    var canvas = document.getElementById('canvas0');
    var context = canvas.getContext('2d');
    var inputContext = canvas.getInputContext();
    var composition = inputContext.composition;

    // Render a caret.
    // NOTE: this just renders a caret rectangle in black for
    // simplicity.
    if (composition.caret.start &gt;= 0) {
        var start = context.measureText(
                composition.text.substring(0, composition.caret.start));
        var end = context.measureText(
                composition.text.substring(0, composition.caret.end));
        context.fillStyle = &rsquo;black&rsquo;;
        context.fillRect(start.width, y, end.width, y + 10);
    }

    // Render the clauses in the composition.
    for (var i = 0; i &lt; composition.clauses.length; ++i) {
        var text = composition.clauses[i].text;
        var metrics = context.measureText(text);
        // Draw the text of this clause.
        context.fillStyle = composition.clauses[i].textColor;
        context.fillText(text, x, y);
        // Draw an underline under the text. For simplicity, this code
        // draws a bold underline for selected clauses or a thin
        // underline for non-selected ones.
        if (composition.clauses[i].selected) {
            context.fillRect(x, y, x + metrics.width, y + 2);
        } else {
            context.fillRect(x, y, x + metrics.width, y + 1);
        }
        x += metrics.width;
    }

    // Move the candidate window outside of the composition text.
    window.inputmethodmanager.moveCandidateWindow(0, y, x, y + 10);
}

function onCompositionEnd(event) {
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;canvas id=&rdquo;canvas0&rdquo; width=&rdquo;640&rdquo; height=&rdquo;480&rdquo;&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
    <p>The next example shows the source for a simple IME that composes
    Japanese Hiragana characters from key strokes.</p>
    <p class="note">This is just a sample and not suitable for real use.</p>
<pre class="example sh_javascript" id="ex-hiragana-keystrokes">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script language="javascript" type="text/javascript"&gt;
var imeActivated = false;
var imeRomajiInput = '';
var imeRomajiTable = {
    'A': '\u3042', 'I': '\u3044', 'U': '\u3046', 'E': '\u3048', 'O': '\u304A',
    /* suppressed */
};

function init() {
    // Disable the system IME associated with this window.
    window.inputmethodmanager.setOpenState(false);

    // Listens the keyboard events.
    var node = document.getElementById('input0');
    node.addEventListener('keydown', onKeyDown, false);
    node.addEventListener('keyup', onKeyUp, false);
}

function onKeyDown(event) {
    // Toggle the input mode when pressing a shift key.
    if (event.key == 'Shift') {
        imeActivated = !imeActivated;
        imeRomajiInput = '';
    }

    // Exit if this IME is not activated.
    if (!imeActivated)
        return true;

    var imeComposition = new Composition;
    var imeConfirm = false;

    if (event.keyCode &lt; 0x20) {
        event.preventDefault();
        return true;
    }

    // Convert the input key strokes to a Japanese character.
    imeRomajiInput += String.fromCharCode(event.keyCode);
    if (imeRomajiTable[imeRomajiInput]) {
        imeComposition.text = imeRomajiTable[imeRomajiInput];
        imeConfirm = true;
        imeRomajiInput = '';
    } else {
        imeComposition.text = imeRomajiInput;
    }

    // Fill the Composition object.
    imeComposition.caret.start = imeComposition.text.length;
    imeComposition.caret.length = 1;
    imeComposition.clauses[0] = new CompositionClause;
    imeComposition.clauses[0].text = imeComposition.text;
    imeComposition.clauses[0].start = 0;
    imeComposition.clauses[0].selected = true;
    imeComposition.clauses[0].textColor = 'currentColor';
    imeComposition.clauses[0].backgroundColor = 'transparent';
    imeComposition.clauses[0].lineStyle = 'solid';
    imeComposition.clauses[0].lineColor = 'black';

    // Send the Composition object to the user agent.
    var context = event.target.getInputContext();
    context.setComposition(imeComposition);
    if (imeConfirm)
        context.confirmComposition();

    // Disable the default action to prevent this key from being
    // inserted.
    event.preventDefault();
    return false;
}

function onKeyUp(event) {
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="init();"&gt;
&lt;textarea id="input0" cols="80" rows="10"&gt;&lt;/textarea&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
    </section>
    <section class='informative' id="background">
      <h1>Background: What’s an Input Method Editor?</h1>
      <p>An <dfn id="IME">IME</dfn> (input-method editor) is an application
      that allows a standard keyboard (such as a US-101 keyboard) to be used to
      type characters and symbols that are not directly represented on the
      keyboard itself. In China, Japan, and Korea, IMEs are used ubiquitously to
      enable standard keyboards to be employed to type the very large number
      of characters required for writing in Chinese, Japanese, and Korean.</p>

      <p>An IME consists of two modules; a <a href="#composer">composer</a>
      and a <a href="#converter">converter</a>.</p>

      <p>A <dfn id="composer">composer</dfn> is a context-free parser that
      composes non-ASCII characters (including phonetic characters) from
      keystrokes.</p>
      <p>A <dfn id="converter">converter</dfn> is a context-sensitive parser that looks up a
      dictionary to convert phonetic characters to a set of ideographic
      characters.</p>
      <p>An <dfn id="ime-clause">IME clause</dfn> is a grammatical word produced in an IME.</p>
      <p>An <dfn id="ime-selected-clause">IME selected clause</dfn> is an <a href="ime-clause">IME clause</a> being composed by an IME.</p>
      <p>An <dfn id="ime-composition">IME composition</dfn>
      is an instance of text produced in an IME. For IMEs that can produce multiple words, an IME composition consists of multiple IME clauses. For IMEs that produce only one word, an IME composition is equal to an IME clause.</p>

      <p>When an IME receives keystrokes, it sends the keystrokes to a
      composer and receives phonetic characters matching to the keystrokes. When
      an IME receives phonetic characters from a composer, it sends the phonetic
      characters to a converter and receives the list of ideographic characters
      matching to the phonetic characters. The following figure shows the
      basic structure of an IME.</p>
      <figure id="fig-ime-structure">
        <p><img height="199" src="images/image10.png" width="615"></p>
        <figcaption>Basic structure of an IME</figcaption>
      </figure>
      <section id="composer-section">
        <h1>Composer</h1>
        <p>A composer consists of two types of composers: a
        <a href="#phonetic-composer">phonetic composer</a>
        and a
        <a href="#radical-composer">radical composer</a>.</p>

        <p>A <dfn id="phonetic-composer">phonetic composer</dfn> composes a phonetic
        character from its ASCII representation.</p>

        <p>A <dfn id="radical-composer">radical composer</dfn> composes a
        phonetic character from <a href="#phonetic-radical">phonetic radicals</a>.</p>

        <p>A <dfn id="phonetic-radical">phonetic radical</dfn> is a character component of a Latin character, a Chinese character, or a Korean character. A Latin character consists of an ASCII character and accent marks, e.g. a character '&aacute;' consists of an ASCII character 'a' and an accent mark '&acute;'. A Chinese character consists of Chinese character components that refer to its semantic origins, e.g. a Chinese character '&#x7565;' consists of two components '&#x7530;' and '&#x5404;'. A Korean character consists of Korean character components that represent consonants or vowels, e.g. a Korean character '&#xac00;' consists of a consonant '&#x3131;' and a vowel '&#x314f;'.</p>

        <p>A <dfn id="composition-window">composition window</dfn> is a window that shows ASCII characters being composed by <a href="#phonetic-composer">phonetic composers</a> or <a href="#phonetic-radical">phonetic radicals</a> being composed by <a href="#radical-composer">radical composers</a>.</p>

        <p>An IME usually shows the text
        being composed by a composer with its own style to distinguish it from the
        existing text. Even though most of composers output phonetic characters,
        some composers (such as Bopomofo composers) output a placeholder character
        instead of phonetic characters while composing text.</p>

        <p class="issue">need to define <i>composition window</i></p>

        <p class="issue">probably should define <i>radical</i></p>

        <p class="issue">probably should define <i>clause</i> here too</p>

        <section id="phonetic-composer-section">
          <h3>Phonetic composer</h3>
          <p>Phonetic composers are not only used for typing Simplified
          Chinese and Japanese, but also used for typing non-ASCII characters (such
          as mathematical symbols, Yi, Amharic, etc.) with a US-101 keyboard. Each of
          these languages has a mapping table from its character to a sequence of
          ASCII characters representing its pronunciation: e.g.,
          &lsquo;&#x304B;&rsquo; to &lsquo;ka&rsquo; in Japanese, and;
          &lsquo;&#x5361;&rsquo; to &lsquo;ka&rsquo; in Simplified Chinese. This
          mapping table is called as Romaji for Japanese and Pinyin for Simplified
          Chinese, respectively. A phonetic composer uses these mapping tables to
          compose a phonetic character from a sequence of ASCII characters produced
          by a US keyboard.</p>
          <p>A phonetic composer for Simplified Chinese outputs the input
          ASCII characters as its composition text.</p>
          <figure id="fig-ascii-composition-text">
            <p><img height="180" src="images/image11.png" width="352"></p>
            <figcaption>Composition text (Simplified Chinese)</figcaption>
          </figure>
          <p>On the other hand, a phonetic composer for Japanese outputs
          phonetic characters when the input ASCII characters have matching phonetic
          characters.</p>
          <figure id="fig-kana-composition-text">
            <p><img height="180" src="images/image13.png" width="352"></p>
            <figcaption>Composition text (Japanese)</figcaption>
          </figure>
          <p>A phonetic composer for mathematical symbols outputs a
          composed mathematical symbol and shows the source keystrokes to its own
          window, which is an example of a composition window.</p>
          <figure id="fig-composition-window">
            <p><img height="214" src="images/image14.png" width="435"></p>
            <figcaption>Composition text (Latex input)</figcaption>
          </figure>
        </section>
        <section id="radical-composer-section">
          <h3>Radical composer</h3>
          <p>Radical composers are mainly used for typing Traditional
          Chinese and Korean with phonetic keyboards. Each phonetic keyboard of these
          languages can produce phonetic radicals: e.g., typing &lsquo;r&rsquo;
          produces &lsquo;&#x3131;&rsquo; on a Korean keyboard; typing
          &lsquo;o&rsquo; produces &lsquo;&#x4EBA;&rsquo; on a Traditional-Chinese
          (or Bopomofo) keyboard, etc. A radical composer composes a phonetic
          character from phonetic radicals given by these keyboards: e.g., typing
          '&#x3131;' (r) and '&#x314F;' (k) produces '&#xAC00;' on a Korean keyboard;
          typing &lsquo;&#x4EBA;&rsquo; (o), &lsquo;&#x5F13;&rsquo; (n), and
          &lsquo;&#x706B;&rsquo; (f) produces &lsquo;&#x4F60;&rsquo; on a
          Traditional-Chinese keyboard, etc.</p>
          <p>A radical composer for Korean outputs the phonetic radicals as
          its composition text.</p>
          <figure id="fig-radical-composer-korean">
            <p><img height="180" src="images/image15.png" width="352"></p>
            <figcaption>Radical composer (Korean)</figcaption>
          </figure>
          <p>A radical composer for Traditional Chinese outputs a
          placeholder character (U+3000) and shows the phonetic radicals being
          composed to its own window. This window is an example of a composition
          window.</p>
          <figure id="fig-radical-composer-chinese">
            <p><img height="180" src="images/image02.png" width="352"></p>
            <figcaption>Radical composer (Traditional Chinese)</figcaption>
          </figure>
          <p>Some platforms (such as Mac and Linux) use radical composers
          for typing accented characters used in European countries. For example,
          typing &lsquo; &#x308; &rsquo; (option+u) and &lsquo;a&rsquo; (a) produces
          &lsquo;&auml;&rsquo; on US keyboards of Mac.</p>
          <figure id="fig-radical-composer-mac">
            <p><img height="177" src="images/image01.png" width="479"></p>
            <figcaption>Radical composer (Mac)</figcaption>
          </figure>
        </section>
      </section>
      <section id="converter-section">
        <h2>Converter</h2>
        <p>A converter is a context-sensitive parser used for replacing
        the outputs of a composer to ideographic characters on Chinese, Japanese,
        and Korean.</p>
        <p class="note">Korean does not use ideographic characters so often.</p>

        <p>Because Chinese, Japanese, and Korean have many homonyms, each sequence of phonetic
        characters usually matches many ideographic characters: e.g., a Japanese
        phonetic character '&#x304B;' matches Japanese ideographic characters
        &lsquo;&#x5316;&rsquo;, &lsquo;&#x79D1;&rsquo;, &lsquo;&#x8AB2;&rsquo;,
        etc.; Pinyin characters &lsquo;ka&rsquo; matches Simplified-Chinese
        ideographic characters &lsquo;&#x5361;', &lsquo;&#x5580;&rsquo;,
        &lsquo;&#x54AF;&rsquo;, etc.; Bopomofo characters
        &lsquo;&#x4EBA;&#x5F13;&rsquo; matches Traditional-Chinese ideographic
        characters &lsquo;&#x4E5E;&rsquo;, &lsquo;&#x4EBF;&rsquo;,
        &lsquo;&#x4E87;&rsquo;, etc.</p>
        <p>A converter looks up a dictionary and shows a
        list of candidates of possible ideographic characters so a user can choose
        one. This list is known as a <dfn id="candidate-list">candidate list</dfn>.
        A candidate list is known as a <dfn id="candidate-window">candidate window</dfn>
        when it has its own window.</p>
        <p>Some Japanese IMEs show annotations in its <a href="#candidate-window">candidate window</a>
        for a character that is not so easy to distinguish from other characters
        (such as full-width alphabets, full-width Katakanas, and half-width
        Katakanas, etc.), as shown in the following figure.</p>
        <figure id="fig-candidate-window-japanese">
          <p><img height="342" src="images/image05.png" width="393"></p>
          <figcaption>Candidate window (Japanese)</figcaption>
        </figure>
        <p>The next figure shows a <a href="#candidate-window">candidate window</a> of a Simplified-Chinese IME.</p>
        <figure id="fig-candidate-window-simplified-chinese">
          <p><img height="308" src="images/image04.png" width="390"></p>
          <figcaption>Candidate window (Simplified Chinese)</figcaption>
        </figure>
        <p>And the next figure shows a <a href="#candidate-window">candidate window</a> of a Traditional-Chinese IME.</p>
        <figure id="fig-candidate-window-traditional-chinese">
          <p><img height="180" src="images/image06.png" width="352"></p>
          <figcaption>Candidate window (Traditional Chinese)</figcaption>
        </figure>
        <p>A converter often integrates an <dfn id="MRU">MRU</dfn> (Most-Recently Used) list.
        Even though there are many ideographic characters for each phonetic
        character (or phonetic radical), a user does not usually use all these
        ideographic characters. A converter uses an <a href="MRU">MRU list</a> to filter out
        ideographic characters not used so often from a
        <a href="#candidate-list">candidate list</a>.
        A converter
        sometimes integrates a grammar parser. A converter that integrates a
        grammar parser splits the given phonetic characters into grammatical
        clauses and converts only one clause at once. When a sequence of phonetic
        characters consists of n clauses and the i-th clause has m_i candidates,
        the total number of the candidates for the input characters become (m_1 *
        m_2 * &hellip; * m_n). To reduce the number of candidates owned by a
        converter, a converter usually processes one clause at once. This clause is
        called as a <dfn id="selected-clause">selected clause</dfn>.</p>

        <p>An IME usually renders a <a href="#selected-clause">selected clause</a> with
        a special style to distinguish it from other clauses, as shown in
        the following figure.</p>
        <figure id="fig-selected-clause">
          <p><img height="346" src="images/image08.png" width="394"></p>
          <figcaption>Selected clause (Japanese)</figcaption>
        </figure>
        <p>When a converter converts two or more clauses, it chooses
        candidates for the selected clause so it becomes grammatically consistent
        with the surrounding clauses: e.g., Japanese converters usually output
        &lsquo;&#x5371;&#x6A5F;&#x4E00;&#x9AEA;&rsquo; (not
        &lsquo;&#x5371;&#x6A5F;&#x4E00;&#x767A;&rsquo;) for Japanese phonetic
        characters &lsquo;&#x304D;&#x304D;&#x3044;&#x3063;&#x3071;&#x3064;&rsquo;
        because &lsquo;&#x5371;&#x6A5F;&#x4E00;&#x767A;&rsquo; is grammatically
        incorrect.</p>
      </section>
    </section>
    <section id="conformance">
      <p><i>More to be written.</i></p>
    </section>
    <section id="terminology">
      <h1>Terminology and algorithms</h1>
      <p><i>To be written.</i></p>
    </section>

    <section>
      <h1>The getInputContext() method</h1>
      <p>For each element, a user agent can choose an IME for the element.
      To control the IME attached to an element, it is a good idea to add a
      method to the HTMLElement interface.</p>
      <p class="issue">If the
      <code>getInputContext()</code>
      method cannot be added to the HTMLElement
      interface, it should be moved to the <a>InputMethodContext</a> interface.</p>

      <dl title='partial interface HTMLElement' class='idl'>
        <dt>InputMethodContext getInputContext()</dt>
          <dd>Returns an InputMethodContext interface associated with this element. By
          default, a user agent returns an InputMethodContext interface representing
          the system IME. To change the behavior of the IME associated with an
          element, authors must first obtain an InputMethodContext interface by
          calling the getInputContext() method of the HTMLElement interface.
          </dd>
      </dl>
    </section>
    <section id="composition-dictionary">
      <h1>The Composition Dictionary</h1>
      <p>This dictionary represents an ongoing IME composition. It provides
      an attribute representing the text being composed by an IME. It also
      provides a method to retrieve attributes of the specified character in the
      composition text.</p>
      <dl title="dictionary Composition" class="idl">
        <dt>readonly attribute Node text</dt>
          <dd>Represents the styled text being composed by an IME. This node may
          have child nodes, e.g. when an <a href="#ime-composition">IME
          composition</a> consists of multiple <a href="#ime-clause">IME clauses</a>,
          this node has child nodes and each child node represents an
          <a href="#ime-clause">IME clause</a>. The text attribute of this node
          is equal to the text
          attribute of a compositionupdate event.
          <dd>Represents the text being composed by an IME. This string is
            equal to the text attribute of a compositionupdate event.</dd>
        <dt>readonly attribute Range caret</dt>
          <dd>Represents the caret in this composition text. The
          CommonAncestorContainer attribute of this range should be <code><a>text</a></code></dd>
      </dl>
    </section>
    <section id="inputmethodcontext-interface">
      <h1>The InputMethodContext Interface</h1>
      <dl title="interface InputMethodContext" class="idl">
        <dt>readonly attribute DOMString source</dt>
          <dd>Represents the name of the IME associated with this context.</dd>
        <dt>readonly attribute Composition composition</dt>
          <dd>Represents the detailed information of the ongoing IME
          composition. When an IME is not composing text, this value MUST be
          null.</dd>
        <dt>boolean setEnabled(in boolean enabled)</dt>
          <dd>
            <p>Controls the state of the IME associated with this context.</p>
            <ul>
              <li>The <var>enabled</var> parameter represents whether a user agent
              activates this IME when the given node gains the input focus. When this
              value is true, a user agent activates an IME when this node gains the input
              focus and sends composition events to the given node even though the node
              is not an editable one, such as a <code>&lt;canvas&gt;</code> element.</li>
            </ul>
          </dd>
        <dt>boolean isEnabled()</dt>
          <dd>Returns the state of the IME associated with this context.</dd>
        <dt>boolean hasComposition()</dt>
          <dd>
            <p>Returns true when the hosting user agent is composing text.</p>
            <p class="note">This function is just copied from WebKit, to solicit opinions
            from developers of JavaScript-based IMEs.</p>
          </dd>
        <dt>void setComposition(Composition composition)</dt>
          <dd>
          <p>Updates the composition information of the hosting user agent.</p>
          <p>When a JavaScript-based IME starts a composition, it MUST call
          this function with the appropriate composition information. When a
          JavaScript-based IME cancels an ongoing composition, it MUST call this
          function with a composition object whose text is empty. A user agent
          sends a compositionstart event when this function is called while
          hasComposition() returns <code>false</code>. On the other hand, a
          user agent sends a compositionupdate event when a Web application calls
          this function while hasComposition() returns <code>true</code>.</p>
          <p class="note">This function is just copied from WebKit, to solicit opinions
          from developers of JavaScript-based IMEs.</p>
          <ul>
          <li>The <var>composition</var> parameter represents the
          information of the new composition.</li>
          </ul>
          </dd>
        <dt>void confirmComposition()</dt>
          <dd>
          <p>Finishes the ongoing composition of the hosting user agent.</p>
          <p>When a Web application calls this function, a user agent sends a
          compositionend event and a textInput event as a user types an
          &lsquo;Accept&rsquo; key as written in
          <a href="http://www.w3.org/TR/DOM-Level-3-Events/#keys-IME">“Input Method Editors” section the DOM Level 3 Events specification</a>
          [[!DOM-LEVEL-3-EVENTS]].</p>
          <p class="note">This function is just copied from WebKit, to solicit opinions
          from developers of JavaScript-based IMEs.</p>
          </dd>
        <dt>void setCaretRectangle(int x, int y, int w, int h)</dt>
          <dd>
            <p>Notifies the rectangle of composition text to a user agent. When
            a user agent renders a
            <a href="#candidate-window">candidate window</a>
            or a composition window, it uses
            this rectangle to prevent these windows from being rendered on this
            rectangle.</p>
            <p>On Windows, this rectangle is used as a parameter for
            ImmSetCandidateWindow(). On Mac, this rectangle is sent when it calls
            [firstRectForCharacterRange:]. On Linux (GTK), this rectangle is used as a
            parameter for gtk_im_context_set_cursor_location().</p>
            <ul>
              <li>The <var>x</var>, <var>y</var>, <var>w</var>, and <var>h</var>
              parameters represent the local coordinates of a
              composition-text rectangle. A user agent MAY need to convert these
              coordinates to the screen coordinates when it shows a
              <a href="#candidate-window">candidate window</a>.</li>
            </ul>
          </dd>
        <dt>boolean setOpenState(boolean open)</dt>
          <dd>
          <p>Controls the state of the IME currently associated with the hosting
          user agent. This function returns <code>true</code> if a user agent can activate or
          deactivate its associated IME.</p>
          <ul>
            <li>The <var>open</var> parameter represents whether a user agent
            enables the IME and disables it.</li>
          </ul>
          <p class="issue">Do we need to notice this event to JavaScript IMEs? If
          so, what is the best option?</p>
          </dd>
      </dl>
    </section>

    <section  class='informative' id="best-practices">
      <h1>Best practices</h1>
    <p>This specification provides two types of interfaces:</p>
    <ol>
      <li>Interfaces for developing IMEs in JavaScript (JavaScript IMEs)</li>
      <li>Interfaces for developing Web applications that are aware of IMEs
      (IME-aware Web applications).</li>
    </ol>
    <p>Moreover, this API depends on several existing specifications to
    minimize the change for existing JavaScript IMEs.</p>
    <p>These dependencies make developers harder to use this API in their
    JavaScript IMEs or IME-aware Web applications. This section describes
    practices for some use-cases.</p>
    <section id="javascript-imes">
      <h1>JavaScript IMEs</h1>
      <p><i>more into to come later…</i></p>
      <section id="composing-text">
        <h1>Composing text</h1>
        <p>Existing JavaScript IMEs use DOM events (e.g., "keydown",
        "keyup", "focus", "blur", etc.) to compose text. To avoid forcing
        developers to change their JavaScript IMEs too much, this API does not
        provide any callbacks; i.e., this API allows them to use their existing
        handlers for DOM events. On the other hand, when a JavaScript IME updates
        its composition text, it needs to call setComposition() instead of
        inserting text by itself. When a JavaScript IME calls setComposition(), a
        user agent sends a composition event and renders the composition text as it
        does for system IMEs. The following figure  illustrates a sequence
        that composes text with a JavaScript IME which emulates the first example
        in the
        <a href="http://www.w3.org/TR/DOM-Level-3-Events/#keys-IME">“Input Method Editors” section the DOM Level 3 Events specification</a>
        [[DOM-LEVEL-3-EVENTS]].</p>
        <figure id="fig-composing-with-js-ime">
          <p><img height="1285" src="images/image12.png" width="707"></p>
          <figcaption>Composing Text with JavaScript IME</figcaption>
        </figure>
      </section>
      <section id="consuming-events">
        <h1>Consuming events</h1>
        <p>When a JavaScript IME calls setComposition(), it MUST call
        preventDefault()&nbsp;to prevent user agents from inserting this character
        to an element.</p>
      </section>
      <section id="enabling-disabling-js-imes">
        <h3>Enabling or Disabling JavaScript IMEs</h3>
        <p>A JavaScript IME should not consume keyboard events when hosting
        Web applications disable it. The JavaScript IME should call
        getInputContext().isEnabled() when it receives a keyboard event and
        does not consume it only when it returns false.</p>
        <figure id="fig-disabled-js-ime">
          <p><img height="296" src="images/image03.png" width="699"></p>
          <figcaption>A JavaScript IME disabled by Web applications</figcaption>
        </figure>
      </section>
      <section id="candidate-window-section">
        <h3>Candidate window</h3>
        <p>Existing JavaScript IMEs usually use so-called CSS layers to
        render their <a href="#candidate-window">candidate window</a>.
        Nevertheless, some JavaScript IMEs use
        absolute coordinates to render their candidate windows (i.e.,
        <code>&lt;div style="position: absolute"&gt;&hellip;&lt;/div&gt;</code>),
        others use relative coordinates to render theirs (i.e.,
        <code>&lt;div style="position: relative"&gt;&hellip;&lt;/div&gt;</code>).
        To satisfy both requests, this API provides two methods that retrieve the
        caret rectangle. This API provides
        window.inputmethodmanager.getCaretRectangle() for JavaScript IMEs that
        need the absolute position of the caret rectangle of the ongoing
        composition text. On the other hand, this API provides
        getInputContext().getCaretRectange() for JavaScript IMEs that need its
        relative position.</p>
      </section>
    </section>
    <section id="ime-aware-webapps">
      <h1>IME-aware Web applications</h1>
      <p>When developers develop an IME-aware Web application, they need to
      decide which IME to use in their Web application: JavaScript IMEs, system
      IMEs, or none. The following sections describe practices of these three
      cases.</p>
      <section id="using-js-imes">
        <h1>Using JavaScript IMEs</h1
        <p>A Web application that uses only JavaScript IMEs MUST disable
        the system IMEs associated with the hosting user agent to prevent keyboard
        events from being consumed by system IMEs. To disable the system IMEs
        associated with a user agent, the Web application MUST call
        getInputContext().setEnabled(true) and
        window.inputmethodmanager.setOpenState(false) when initializing itself
        and when it gains the focus.</p>
        <figure id="disabling-system-ime">
          <p><img height="373" src="images/image07.png" width="657"></p>
          <figcaption>Disable the system IME and enable a JavaScript IME</figcaption>
        </figure>
        <p>JavaScript IMEs MAY not dispatch keyboard events consumed by them
        to Web applications. Therefore, developers should not depend on such
        keyboard events to develop their Web applications when using JavaScript
        IMEs.</p>
      </section>
      <section id="using-system-imes">
        <h1>Using system IMEs</h1>
        <p>On the other hand, a Web application that uses the system IME
        MUST enable the system IME when it becomes active as well as it disables
        the JavaScript IMEs. JavaScript IMEs MAY consume keyboard events even
        though the Web application calls getInputContext().setEnabled(false). To
        prevent such JavaScript IMEs from consuming keyboard events, the Web
        application should add event handlers to keyboard events.</p>
        <figure id="enabling-system-ime">
          <p><img height="469" src="images/image09.png" width="657"></p>
          <figcaption>Enable the system IME and disable JavaScript IMEs</figcaption>
        </figure>
      </section>
      <section id="does-not-use-imes">
        <h1>Does not use IMEs</h1>
        <p>When a Web application does not use any IMEs, it…</p>
        <figure id="no-imes">
          <p><img height="305" src="images/image00.png" width="657"></p>
          <figcaption>[to come]</figcaption>
        </figure>
        </section>
      </section>
  </body>
</html>
