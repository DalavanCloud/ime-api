<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Input Method Editor API (Proposal)</title>
    <style rel="stylesheet">
      body {
        counter-reset: figcaption;
        counter-reset: example;
      }
      figcaption {
        font-weight: bold;
      }
      figcaption:before {
        font-weight: bold;
        content: "Figure " counter(figcaption) ": ";
        counter-increment: figcaption;
      }
      var {
        font-weight: bold;
        color: green; 
        padding-left: 2px;
        padding-right: 4px;
      }
      .tocline {
        padding-top: 2px;
      }
      .ed_mailto:before {
        content: "<";
      }
      .ed_mailto:after {
        content: ">";
      }
      pre.example::before {
        content: "Example " counter(example) " " !important;
        counter-increment: example;
      }
    </style>
    <script class='remove'>
      function addEllipsis(id) {
        document.getElementById(id).childNodes.item(2).textContent = "\n    …\n";
      }
      function removeNodes(nodesToRemove) {
        var i, j;
        for (i = 0; i < nodesToRemove.length; ++i) {
          for (j = 0; j < nodesToRemove[i].length; ++j) {
            nodesToRemove[i][j].parentNode.removeChild(nodesToRemove[i][j]);
          }
        }
      }
    </script>
    <script class='remove'>
      function getLastModifiedDate() {
        var d = new Date(document.lastModified);
        return d.toISOString().substring(0,10);
      }
    </script>
    <script type="text/javascript" src='ReSpec.js/js/respec.js' class='remove'></script>
    <script type="text/javascript" class='remove'>
    var respecConfig = 
      {
          specStatus: "unofficial",
          shortName:  "ime-api",
          edDraftURI: "http://dvcs.w3.org/hg/ime-api/", // FIXME
          editors: [
                {   name:       "Hironori Bono (坊野 博典)",
                    company:    "Google",
                    mailto:     "hbono@google.com"
                },
                {   name:       "Kenji Baheux",
                    company:    "Google",
                    mailto:     "kenjibaheux@google.com"
                },
          ],
          wgURI:        "[to come]",
          wg:           "[to come]",
          wgPublicList: "public-webapps",
          wgPatentURI:  "[to come]",
          additionalCopyrightHolders: "Hironori Bono, Kenji Baheux",
          publishDate: getLastModifiedDate(),
          extraCSS: ["ReSpec.js/css/respec.css"],
          after: function () {
            var nodesToRemove = [
              document.querySelectorAll("table.parameters"),
              document.querySelectorAll("li.tocline > a[href^='#attributes']"),
              document.querySelectorAll("li.tocline > a[href^='#methods']"),
             ]
            addEllipsis('idl-def-HTMLElement');
            removeNodes(nodesToRemove);
          }
      }
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>This specification defines an API that provides Web applications
      with scripted access to an IME (Input-Method Editor) associated with the
      hosting user agent. The IME API  includes:</p>
      <ul>
       <li>An InputMethodManager interface, which provides methods to
        retrieve the detailed data of an ongoing composition and to update it</li>
       <li>A Composition interface, which represents read-only attributes
        about the current composition such as its string, its length, its target
        clause.</li>
      </ul>
      <p>This API is designed to be used in conjunction with DOM events and
      elements on the web platform, notably: composition events and the
      <a href="http://dev.w3.org/html5/2dcontext/">Canvas 2D Context API</a> [[CANVAS-2D]].</p>
    </section>
    <section id='sotd'>
      <p>
        <i>[more to come later…]</i>
      </p>
    </section>
    <section class='informative' id="introduction">
      <h2>Introduction</h2>
      <p>Even though HTML5 APIs allow developers to implement very
      complicated web applications such as a visual chat application using an SVG
      or a <code>&lt;canvas&gt;</code> element, developers have difficulties when implementing
      a web application that controls an IME. To provide ability to notify the
      data of an IME associated with the hosting user-agent to web applications,
      <a href="http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html">the DOM Level 3 Events specification</a>
      [[DOM-LEVEL-3-EVENTS]]
      introduces composition events. To use these events, web applications
      can retrieve the text being composed with an IME. On the other hand, web
      applications have difficulties when they manipulate IMEs on non-editable
      elements such as <code>&lt;canvas&gt;</code> elements:</p>
      <ul>
        <li>Web applications cannot tell user agents whether Web
        applications render composition text by themselves or ask user agents to
        render it;</li>
        <li>Web applications cannot tell user agents the place where user
        agents render composition text;</li>
        <li>Web applications cannot tell user agents whether they render
        <a href="#candidate-window">candidate windows</a>
        by themselves;</li>
        <li>Web applications cannot tell user agents the place where user
        agents render
        <a href="#candidate-window">candidate windows</a>.</li>
      </ul>
    <p>HTML5 also introduces APIs useful for implementing an IME, e.g., Web
    Storage can store an IME dictionary, WebSocket and XMLHttpRequest allow to
    send a server request that looks up an IME dictionary, etc. In fact,
    web-application developers publish IMEs that use these APIs. But, it is not
    so easy to make these JavaScript-based IMEs work on all user agents because
    they often rely on APIs specific to the hosting user-agent, such as
    extension APIs.</p>
    <p>To solve these IME-related problems, this specification introduces
    an IME API that allows developers to read and write the composition data
    owned by user agents. Moreover, this specification introduces interfaces
    for compositions so Web applications can read their detailed data and
    update it. A Composition object provides a reference to the ongoing
    composition of an IME so Web applications can retrieve its text and
    attributes.</p>
    <p>The use of interfaces allows Web applications the ability to set the
    position of a composition window and retrieves the attributed text of the
    ongoing composition. The examples will be illustrative.</p>

    <p>The following example shows the source for a web application that
    renders composition text by itself and uses the
    <a href="#candidate-window">candidate window</a>
    provided by an IME.</p>
<pre class="example sh_javascript" id="ex-candidate-window">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script language="javascript" type="text/javascript"&gt;
function init() {
    window.inputmethodmanager.setOpenState(true);
    var node = document.getElementById('canvas0');
    node.getInputContext().setEnable(true);
    node.addEventListener('compositionstart', onCompositionStart, false);
    node.addEventListener('compositionupdate', onCompositionUpdate, false);
    node.addEventListener('compositionend', onCompositionEnd, false);
}

function onCompositionStart(event) {
}

function onCompositionUpdate(event) {
    var x = 0;
    var y = 0;
    var canvas = document.getElementById('canvas0');
    var context = canvas.getContext('2d');
    var inputContext = canvas.getInputContext();
    var composition = inputContext.composition;

    // Render a caret.
    // NOTE: this just renders a caret rectangle in black for
    // simplicity.
    if (composition.caret.start &gt;= 0) {
        var start = context.measureText(
                composition.text.substring(0, composition.caret.start));
        var end = context.measureText(
                composition.text.substring(0, composition.caret.end));
        context.fillStyle = &rsquo;black&rsquo;;
        context.fillRect(start.width, y, end.width, y + 10);
    }

    // Render the clauses in the composition.
    for (var i = 0; i &lt; composition.clauses.length; ++i) {
        var text = composition.clauses[i].text;
        var metrics = context.measureText(text);
        // Draw the text of this clause.
        context.fillStyle = composition.clauses[i].textColor;
        context.fillText(text, x, y);
        // Draw an underline under the text. For simplicity, this code
        // draws a bold underline for selected clauses or a thin
        // underline for non-selected ones.
        if (composition.clauses[i].selected) {
            context.fillRect(x, y, x + metrics.width, y + 2);
        } else {
            context.fillRect(x, y, x + metrics.width, y + 1);
        }
        x += metrics.width;
    }

    // Move the candidate window outside of the composition text.
    window.inputmethodmanager.moveCandidateWindow(0, y, x, y + 10);
}

function onCompositionEnd(event) {
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;canvas id=&rdquo;canvas0&rdquo; width=&rdquo;640&rdquo; height=&rdquo;480&rdquo;&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
    <p>The following shows an example of a simple IME that composes
    Japanese Hiragana characters from key strokes.</p>
    <p class="note">This is just a sample and not suitable for real use.</p>
<pre class="example sh_javascript" id="ex-hiragana-keystrokes">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script language="javascript" type="text/javascript"&gt;
var imeActivated = false;
var imeRomajiInput = '';
var imeRomajiTable = {
    'A': '\u3042', 'I': '\u3044', 'U': '\u3046', 'E': '\u3048', 'O': '\u304A',
    /* suppressed */
};

function init() {
    // Disable the system IME associated with this window.
    window.inputmethodmanager.setOpenState(false);

    // Listens the keyboard events.
    var node = document.getElementById('input0');
    node.addEventListener('keydown', onKeyDown, false);
    node.addEventListener('keyup', onKeyUp, false);
}

function onKeyDown(event) {
    // Toggle the input mode when pressing a shift key.
    if (event.key == 'Shift') {
        imeActivated = !imeActivated;
        imeRomajiInput = '';
    }

    // Exit if this IME is not activated.
    if (!imeActivated)
        return true;

    var imeComposition = new Composition;
    var imeConfirm = false;

    if (event.keyCode &lt; 0x20) {
        event.preventDefault();
        return true;
    }

    // Convert the input key strokes to a Japanese character.
    imeRomajiInput += String.fromCharCode(event.keyCode);
    if (imeRomajiTable[imeRomajiInput]) {
        imeComposition.text = imeRomajiTable[imeRomajiInput];
        imeConfirm = true;
        imeRomajiInput = '';
    } else {
        imeComposition.text = imeRomajiInput;
    }

    // Fill the Composition object.
    imeComposition.caret.start = imeComposition.text.length;
    imeComposition.caret.length = 1;
    imeComposition.clauses[0] = new CompositionClause;
    imeComposition.clauses[0].text = imeComposition.text;
    imeComposition.clauses[0].start = 0;
    imeComposition.clauses[0].selected = true;
    imeComposition.clauses[0].textColor = 'currentColor';
    imeComposition.clauses[0].backgroundColor = 'transparent';
    imeComposition.clauses[0].lineStyle = 'solid';
    imeComposition.clauses[0].lineColor = 'black';

    // Send the Composition object to the user agent.
    var context = event.target.getInputContext();
    context.setComposition(imeComposition);
    if (imeConfirm)
        context.confirmComposition();

    // Disable the default action to prevent this key from being
    // inserted.
    event.preventDefault();
    return false;
}

function onKeyUp(event) {
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body onload="init();"&gt;
&lt;textarea id="input0" cols="80" rows="10"&gt;&lt;/textarea&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
    </section>
    <section class='informative' id="background">
      <h1>Background: What’s an Input Method Editor?</h1>
      <p>An <dfn id="IME">IME</dfn> (Input Method Editor) is an application that allows users
      to type the thousands of characters with a standard US-101 keyboard or
      phonetic keyboards used in China, Japan, and Korea. An IME consists of two
      modules; a <a href="#composer">composer</a> and a <a href="#converter">converter</a>.</p>
      <p>A <dfn id="composer">composer</dfn>
      is a context-free parser that composes non-ASCII characters (including phonetic characters) from
      keystrokes.</p>
      <p>A <dfn id="converter">converter</dfn> is a context-sensitive parser that looks up a
      dictionary to convert phonetic characters to a set of ideographic
      characters.</p>
      <p>When an IME receives keystrokes, it sends the keystrokes to a
      composer and receives phonetic characters matching to the keystrokes. When
      an IME receives phonetic characters from a composer, it sends the phonetic
      characters to a converter and receives the list of ideographic characters
      matching to the phonetic characters. The following figure shows the
      basic structure of an IME.</p>
      <figure id="fig-ime-structure">
        <p><img height="199" src="images/image10.png" width="615"></p>
        <figcaption>Basic structure of an IME</figcaption>
      </figure>
      <section id="composer-section">
        <h1>Composer</h1>
        <p>A composer consists of two types of composers: a
        <a href="#phonetic-composer">phonetic composer</a>
        and a
        <a href="#radical-composer">radical composer</a>.</p>

        <p>A <dfn id="phonetic-composer">phonetic composer</dfn> composes a phonetic
        character from its ASCII representation.</p>

        <p>A <dfn id="radical-composer">radical composer</dfn> composes a
        phonetic character from phonetic radicals.</p>

        <p>An IME usually shows the text
        being composed by a composer with its own style to distinguish it from the
        existing text. Even though most of composers output phonetic characters,
        some composers (such as Bopomofo composers) output a placeholder character
        instead of phonetic characters while composing text.</p>

        <p class="issue">need to define <i>composition window</i></p>

        <p class="issue">probably should define <i>radical</i></p>

        <section id="phonetic-composer-section">
          <h3>Phonetic composer</h3>
          <p>Phonetic composers are not only used for typing Simplified
          Chinese and Japanese, but also used for typing non-ASCII characters (such
          as mathematical symbols, Yi, Amharic, etc.) with a US-101 keyboard. Each of
          these languages has a mapping table from its character to a sequence of
          ASCII characters representing its pronunciation: e.g.,
          &lsquo;&#12363;&rsquo; to &lsquo;ka&rsquo; in Japanese, and;
          &lsquo;&#21345;&rsquo; to &lsquo;ka&rsquo; in Simplified Chinese. This
          mapping table is called as Romaji for Japanese and Pinyin for Simplified
          Chinese, respectively. A phonetic composer uses these mapping tables to
          compose a phonetic character from a sequence of ASCII characters produced
          by a US keyboard.</p>
          <p>A phonetic composer for Simplified Chinese outputs the input
          ASCII characters as its composition text.</p>
          <figure id="fig-ascii-composition-text">
            <p><img height="180" src="images/image11.png" width="352"></p>
            <figcaption>Composition text (Simplified Chinese)</figcaption>
          </figure>
          <p>On the other hand, a phonetic composer for Japanese outputs
          phonetic characters when the input ASCII characters have matching phonetic
          characters.</p>
          <figure id="fig-kana-composition-text">
            <p><img height="180" src="images/image13.png" width="352"></p>
            <figcaption>Composition text (Japanese)</figcaption>
          </figure>
          <p>A phonetic composer for mathematical symbols outputs a
          composed mathematical symbol and shows the source keystrokes to its own
          window, which is an example of a composition window.</p>
          <figure id="fig-composition-window">
            <p><img height="214" src="images/image14.png" width="435"></p>
            <figcaption>Composition text (Latex input)</figcaption>
          </figure>
        </section>
        <section id="radical-composer-section">
          <h3>Radical composer</h3>
          <p>Radical composers are mainly used for typing Traditional
          Chinese and Korean with phonetic keyboards. Each phonetic keyboard of these
          languages can produce phonetic radicals: e.g., typing &lsquo;r&rsquo;
          produces &lsquo;&#12593;&rsquo; on a Korean keyboard; typing
          &lsquo;o&rsquo; produces &lsquo;&#20154;&rsquo; on a Traditional-Chinese
          (or Bopomofo) keyboard, etc. A radical composer composes a phonetic
          character from phonetic radicals given by these keyboards: e.g., typing
          '&#12593;' (r) and '&#12623;' (k) produces '&#44032;' on a Korean keyboard;
          typing &lsquo;&#20154;&rsquo; (o), &lsquo;&#24339;&rsquo; (n), and
          &lsquo;&#28779;&rsquo; (f) produces &lsquo;&#20320;&rsquo; on a
          Traditional-Chinese keyboard, etc.</p>
          <p>A radical composer for Korean outputs the phonetic radicals as
          its composition text.</p>
          <figure id="fig-radical-composer-korean">
            <p><img height="180" src="images/image15.png" width="352"></p>
            <figcaption>Radical composer (Korean)</figcaption>
          </figure>
          <p>A radical composer for Traditional Chinese outputs a
          placeholder character (U+3000) and shows the phonetic radicals being
          composed to its own window. This window is an example of a composition
          window.</p>
          <figure id="fig-radical-composer-chinese">
            <p><img height="180" src="images/image02.png" width="352"></p>
            <figcaption>Radical composer (Traditional Chinese)</figcaption>
          </figure>
          <p>Some platforms (such as Mac and Linux) use radical composers
          for typing accented characters used in European countries. For example,
          typing &lsquo; &#776; &rsquo; (option+u) and &lsquo;a&rsquo; (a) produces
          &lsquo;&auml;&rsquo; on US keyboards of Mac.</p>
          <figure id="fig-radical-composer-mac">
            <p><img height="177" src="images/image01.png" width="479"></p>
            <figcaption>Radical composer (Mac)</figcaption>
          </figure>
        </section>
      </section>
      <section id="converter-section">
        <h2>Converter</h2>
        <p>A converter is a context-sensitive parser used for replacing
        the outputs of a composer to ideographic characters on Chinese, Japanese,
        and Korean.</p>
        <p class="note">Korean does not use ideographic characters so often.</p>

        <p>Because Chinese, Japanese, and Korean have many homonyms, each sequence of phonetic
        characters usually matches many ideographic characters: e.g., a Japanese
        phonetic character '&#12363;' matches Japanese ideographic characters
        &lsquo;&#21270;&rsquo;, &lsquo;&#31185;&rsquo;, &lsquo;&#35506;&rsquo;,
        etc.; Pinyin characters &lsquo;ka&rsquo; matches Simplified-Chinese
        ideographic characters &lsquo;&#21345;', &lsquo;&#21888;&rsquo;,
        &lsquo;&#21679;&rsquo;, etc.; Bopomofo characters
        &lsquo;&#20154;&#24339;&rsquo; matches Traditional-Chinese ideographic
        characters &lsquo;&#20062;&rsquo;, &lsquo;&#20159;&rsquo;,
        &lsquo;&#20103;&rsquo;, etc.</p>
        <p>A converter looks up a dictionary and shows a
        list of candidates of possible ideographic characters so a user can choose
        one. This list is known as a <dfn id="candidate-list">candidate list</dfn>.
        A candidate list is known as a <dfn id="candidate-window">candidate window</dfn>
        when it has its own window.</p>
        <p>Some Japanese IMEs show annotations in its <a href="#candidate-window">candidate window</a>
        for a character that is not so easy to distinguish from other characters
        (such as full-width alphabets, full-width Katakanas, and half-width
        Katakanas, etc.), as shown in the following figure.</p>
        <figure id="fig-candidate-window-japanese">
          <p><img height="342" src="images/image05.png" width="393"></p>
          <figcaption>Candidate window (Japanese)</figcaption>
        </figure>
        <p>The next figure shows a <a href="#candidate-window">candidate window</a> of a Simplified-Chinese IME.</p>
        <figure id="fig-candidate-window-simplified-chinese">
          <p><img height="308" src="images/image04.png" width="390"></p>
          <figcaption>Candidate window (Simplified Chinese)</figcaption>
        </figure>
        <p>And the next figure shows a <a href="#candidate-window">candidate window</a> of a Traditional-Chinese IME.</p>
        <figure id="fig-candidate-window-traditional-chinese">
          <p><img height="180" src="images/image06.png" width="352"></p>
          <figcaption>Candidate window (Traditional Chinese)</figcaption>
        </figure>
        <p>A converter often integrates an <dfn id="MRU">MRU</dfn> (Most-Recently Used) list.
        Even though there are many ideographic characters for each phonetic
        character (or phonetic radical), a user does not usually use all these
        ideographic characters. A converter uses an <a href="MRU">MRU list</a> to filter out
        ideographic characters not used so often from a
        <a href="#candidate-list">candidate list</a>.
        A converter
        sometimes integrates a grammar parser. A converter that integrates a
        grammar parser splits the given phonetic characters into grammatical
        clauses and converts only one clause at once. When a sequence of phonetic
        characters consists of n clauses and the i-th clause has m_i candidates,
        the total number of the candidates for the input characters become (m_1 *
        m_2 * &hellip; * m_n). To reduce the number of candidates owned by a
        converter, a converter usually processes one clause at once. This clause is
        called as a <dfn id="selected-clause">selected clause</dfn>.</p>

        <p>An IME usually renders a <a href="#selected-clause">selected clause</a> with
        a special style to distinguish it from other clauses, as shown in
        the following figure.</p>
        <figure id="fig-selected-clause">
          <p><img height="346" src="images/image08.png" width="394"></p>
          <figcaption>Selected clause (Japanese)</figcaption>
        </figure>
        <p>When a converter converts two or more clauses, it chooses
        candidates for the selected clause so it becomes grammatically consistent
        with the surrounding clauses: e.g., Japanese converters usually output
        &lsquo;&#21361;&#27231;&#19968;&#39658;&rsquo; (not
        &lsquo;&#21361;&#27231;&#19968;&#30330;&rsquo;) for Japanese phonetic
        characters &lsquo;&#12365;&#12365;&#12356;&#12387;&#12401;&#12388;&rsquo;
        because &lsquo;&#21361;&#27231;&#19968;&#30330;&rsquo; is grammatically
        incorrect.</p>
      </section>
    </section>
    <section id="conformance">
      <p><i>More to be written.</i></p>
    </section>
    <section id="terminology">
      <h1>Terminology and algorithms</h1>
      <p><i>To be written.</i></p>
    </section>

    <section>
      <h1>The getInputContext() method</h1>
      <p>For each element, a user agent can choose an IME for the element.
      To control the IME attached to an element, it is a good idea to add a
      method to the HTMLElement interface.</p>
      <p class="issue">If the
      <a href="#widl-HTMLElement-getInputContext-Object">getInputContext()</a>
      method cannot be added to the HTMLElement
      interface, it should be moved to the InputMethodManager interface.</p>

      <dl title='interface HTMLElement' class='idl'>
        <dt>Object getInputContext()</dt>
          <dd>Returns an InputMethodContext interface associated with this element. By
          default, a user agent returns an InputMethodContext interface representing
          the system IME. To change the behavior of the IME associated with an
          element, authors must first obtain an InputMethodContext interface by
          calling the getInputContext() method of the HTMLElement interface.
          </dd>
      </dl>
    </section>
    <section id="composition-interface">
      <h1>The Composition Interface</h1>
      <p>This interface represents an ongoing IME composition. It provides
      an attribute representing the text being composed by an IME. It also
      provides a method to retrieve attributes of the specified character in the
      composition text.</p>
      <dl title="interface Composition" class="idl">
        <dt>readonly attribute DOMString text</dt>
          <dd>Represents the text being composed by an IME. This string is
            equal to the text attribute of a compositionupdate event.</dd>
        <dt>readonly attribute CompositionCaret caret</dt>
          <dd>Represents the caret in this composition text.</dd>
        <dt>readonly attribute CompositionClauseList clauses</dt>
          <dd>Returns the clauses in the composition text.</dd>
      </dl>
    </section>
    <section id="compositioncaret-interface">
      <h1>The CompositionCaret Interface</h1>
      <p>This interface represents the caret in the composition text. When
      the value of its &rdquo;length&rdquo;&nbsp;attribute is <code>0</code>, an IME uses a
      vertical bar as an its cursor. Otherwise, an IME uses a block cursor as its
      cursor. When an IME does not show a caret, both values MUST be <code>-1</code>.</p>
      <dl title="interface CompositionCaret" class="idl">
        <dt>readonly attribute int start</dt>
          <dd>Represents the beginning of the caret, in characters. This
          value is less than the length of the composition text, or
          <code>-1</code> if an IME does not show a caret. The default value
          is <code>-1</code>.</dd>
        <dt>readonly attribute int length</dt>
          <dd>Represents the length of the caret, in characters. The default
          value is <code>-1</code>.</dd>
      </dl>
    </section>
    <section id="compositionclause-interface">
      <h1>The CompositionClause Interface</h1>
      <p>This interface represents a clause of the composition text. This
      interface also represents attributes of the clause retrieved from a user
      agent so Web applications can render the clauses as a user agent does.</p>
      <p class="note">Retrieving attributes is not supported by all
      operating systems or all IMEs.</p>
      <p>When a user agent cannot retrieve attributes from an
      operating system, it sets default values for them.</p>
      <dl title="interface CompositionClause" class="idl">
        <dt>readonly attribute DOMString text</dt>
          <dd>Represents the text of this clause.</dd>
        <dt>readonly attribute int start</dt>
          <dd>Represents the offset of this clause from the beginning of the
          composition text, in characters.</dd>
        <dt>readonly attribute boolean selected</dt>
          <dd>Represents whether this clause is a selected clause.</dd>
        <dt>readonly attribute DOMString textColor</dt>
        <dd>Represents the text color used by a user agent to render this
        clause. This string MUST be parsed as a CSS color value.
        The default value is <code>currentColor</code>.</dd>
        <dt>readonly attribute DOMString backgroundColor</dt>
          <dd>Represents the background color used by a user agent to render
          this clause. This string MUST be parsed as a CSS color value. The
          default value is "<code>transparent</code>".</dd>
        <dt>readonly attribute DOMString lineStyle</dt>
          <dd>Represents the style of an underline used by a user agent to
          render under this clause. This value MUST be one defined in the
          ‘text-underline-style’ of CSS 3; i.e.,
          "<code>none</code>", "<code>solid</code>", "<code>double</code>",
          "<code>dotted</code>", "<code>dashed</code>", and
          "<code>wave</code>". The default value is "<code>solid</code>".</dd>
        <dt>readonly attribute DOMString lineColor</dt>
          <dd>Represents the color of an underline used by a user agent. If
          lineStyle is &rdquo;none&rdquo;, this value is undefined.
          The default value is <code>currentColor</code>.</dd>
      </dl>
    </section>
    <section id="compositionclauselist-sequence">
      <h1>The CompositionClauseList sequence</h1>
      <div title="typedef sequence&lt;CompositionClause> CompositionClauseList" class="idl"></div>
    </section>
    <section id="inputmethodcontext-interface">
      <h1>The InputMethodContext Interface</h1>
      <dl title="interface InputMethodContext" class="idl">
        <dt>readonly attribute DOMString source</dt>
          <dd>Represents the name of the IME associated with this context.</dd>
        <dt>readonly attribute Composition composition</dt>
          <dd>Represents the detailed information of the ongoing IME
          composition. When an IME is not composing text, this value MUST be
          null.</dd>
        <dt>boolean setEnabled(in boolean enabled)</dt>
          <dd>
            <p>Controls the state of the IME associated with this context.</p>
            <ul>
              <li>The <var>enabled</var> parameter represents whether a user agent
              activates this IME when the given node gains the input focus. When this
              value is true, a user agent activates an IME when this node gains the input
              focus and sends composition events to the given node even though the node
              is not an editable one, such as a <code>&lt;canvas&gt;</code> element.</li>
            </ul>
          </dd>
        <dt>boolean isEnabled()</dt>
          <dd>Returns the state of the IME associated with this context.</dd>
        <dt>bool setInputMode(DOMString script, DOMString modifier)</dt>
          <dd>
          <p>Provides a hint to the user agent so it can select the
          appropriate input mode of its associated IME. This function returns <code>true</code>
          when a user agent can change the input mode of its associated IME.
          Otherwise it returns <code>false</code>.</p>
          <p class="note">The parameters for this function are copied from
          <a href="http://www.w3.org/TR/xforms/#mode">Annex E of the &ldquo;XForms 1.0&rdquo; specification</a>
          [[XFORMS10]], for consistency with that specification.</p>
          <ul>
            <li>The <var>script</var> parameter represents a Unicode script name.</li>
            <li>The <var>modifier</var> parameter represents a string added
            to the script name in order to more closely specify the kind of characters:
            e.g., "<code>digits</code>", "<code>halfWidth</code>", "<code>kotei</code>", etc.</li>
          </ul>
          </dd>
        <dt>boolean hasComposition()</dt>
          <dd>
            <p>Returns true when the hosting user-agent is composing text.</p>
            <p class="note">This function is just copied from WebKit, to solicit opinions
            from developers of JavaScript-based IMEs.</p>
          </dd>
        <dt>void setComposition(in Composition composition)</dt>
          <dd>
          <p>Updates the composition information of the hosting user-agent.</p>
          <p>When a JavaScript-based IME starts a composition, it MUST call
          this function with the appropriate composition information. When a
          JavaScript-based IME cancels an ongoing composition, it MUST call this
          function with a composition object whose text is empty. A user agent
          sends a compositionstart event when this function is called while
          hasComposition() returns <code>false</code>. On the other hand, a
          user agent sends a compositionupdate event when a web application calls
          this function while hasComposition() returns <code>true</code>.</p>
          <p class="note">This function is just copied from WebKit, to solicit opinions
          from developers of JavaScript-based IMEs.</p>
          <ul>
          <li>The <var>composition</var> parameter represents the
          information of the new composition.</li>
          </ul>
          </dd>
        <dt>void confirmComposition()</dt>
          <dd>
          <p>Finishes the ongoing composition of the hosting user-agent.</p>
          <p>When a web application calls this function, a user-agent sends a
          compositionend event and a textInput event as a user types an
          &lsquo;Accept&rsquo; key as written in
          <a href="http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#keys-IME">“Input Method Editors” section the DOM Level 3 Events specification</a>
          [[!DOM-LEVEL-3-EVENTS]].</p>
          <p class="note">This function is just copied from WebKit, to solicit opinions
          from developers of JavaScript-based IMEs.</p>
          </dd>
        <dt>void setCaretRectangle(in int x, in int y, in int w, in int h)</dt>
          <dd>
            <p>Notifies the rectangle of composition text to a user agent. When
            a user agent renders a
            <a href="#candidate-window">candidate window</a>
            or a composition window, it uses
            this rectangle to prevent these windows from being rendered on this
            rectangle.</p>
            <p>On Windows, this rectangle is used as a parameter for
            ImmSetCandidateWindow(). On Mac, this rectangle is sent when it calls
            [firstRectForCharacterRange:]. On Linux (GTK), this rectangle is used as a
            parameter for gtk_im_context_set_cursor_location().</p>
            <ul>
              <li>The <var>x</var>, <var>y</var>, <var>w</var>, and <var>h</var>
              parameters represent the local coordinates of a
              composition-text rectangle. A user-agent MAY need to convert these
              coordinates to the screen coordinates when it shows a
              <a href="#candidate-window">candidate window</a>.</li>
            </ul>
          </dd>
        <dt>boolean setOpenState(in boolean open)</dt>
          <dd>
          <p>Controls the state of the IME currently associated with the hosting
          user-agent. This function returns <code>true</code> if a user agent can activate or
          deactivate its associated IME.</p>
          <ul>
            <li>The <var>open</var> parameter represents whether a user agent
            enables the IME and disables it.</li>
          </ul>
          <p class="issue">Do we need to notice this event to JavaScript IMEs? If
          so, what is the best option?</p>
          </dd>
      </dl>
    </section>

    <section  class='informative' id="best-practices">
      <h1>Best practices</h1>
    <p>This specification provides two types of interfaces:</p>
    <ol>
      <li>Interfaces for developing IMEs in JavaScript (JavaScript IMEs)</li>
      <li>Interfaces for developing web applications that are aware of IMEs
      (IME-aware web applications).</li>
    </ol>
    <p>Moreover, this API depends on several existing specifications to
    minimize the change for existing JavaScript IMEs.</p>
    <p>These dependencies make developers harder to use this API in their
    JavaScript IMEs or IME-aware web applications. This section describes
    practices for some use-cases.</p>
    <section id="javascript-imes">
      <h1>JavaScript IMEs</h1>
      <p><i>more into to come later…</i></p>
      <section id="composing-text">
        <h1>Composing text</h1>
        <p>Existing JavaScript IMEs use DOM events (e.g., "keydown",
        "keyup", "focus", "blur", etc.) to compose text. To avoid forcing
        developers to change their JavaScript IMEs too much, this API does not
        provide any callbacks; i.e., this API allows them to use their existing
        handlers for DOM events. On the other hand, when a JavaScript IME updates
        its composition text, it needs to call setComposition() instead of
        inserting text by itself. When a JavaScript IME calls setComposition(), a
        user agent sends a composition event and renders the composition text as it
        does for system IMEs. The following figure  illustrates a sequence
        that composes text with a JavaScript IME which emulates the first example
        in the
        <a href="http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#keys-IME">“Input Method Editors” section the DOM Level 3 Events specification</a>
        [[DOM-LEVEL-3-EVENTS]].</p>
        <figure id="fig-composing-with-js-ime">
          <p><img height="1285" src="images/image12.png" width="707"></p>
          <figcaption>Composing Text with JavaScript IME</figcaption>
        </figure>
      </section>
      <section id="consuming-events">
        <h1>Consuming events</h1>
        <p>When a JavaScript IME calls setComposition(), it MUST call
        preventDefault()&nbsp;to prevent user-agents from inserting this character
        to an element.</p>
      </section>
      <section id="enabling-disabling-js-imes">
        <h3>Enabling or Disabling JavaScript IMEs</h3>
        <p>A JavaScript IME should not consume keyboard events when hosting
        web applications disable it. The JavaScript IME should call
        getInputContext().isEnabled() when it receives a keyboard event and
        does not consume it only when it returns false.</p>
        <figure id="fig-disabled-js-ime">
          <p><img height="296" src="images/image03.png" width="699"></p>
          <figcaption>A JavaScript IME disabled by web applications</figcaption>
        </figure>
      </section>
      <section id="candidate-window-section">
        <h3>Candidate window</h3>
        <p>Existing JavaScript IMEs usually use so-called CSS layers to
        render their <a href="#candidate-window">candidate window</a>.
        Nevertheless, some JavaScript IMEs use
        absolute coordinates to render their candidate windows (i.e.,
        <code>&lt;div style="position: absolute"&gt;&hellip;&lt;/div&gt;</code>),
        others use relative coordinates to render theirs (i.e.,
        <code>&lt;div style="position: relative"&gt;&hellip;&lt;/div&gt;</code>).
        To satisfy both requests, this API provides two methods that retrieve the
        caret rectangle. This API provides
        window.inputmethodmanager.getCaretRectangle() for JavaScript IMEs that
        need the absolute position of the caret rectangle of the ongoing
        composition text. On the other hand, this API provides
        getInputContext().getCaretRectange() for JavaScript IMEs that need its
        relative position.</p>
      </section>
    </section>
    <section id="ime-aware-webapps">
      <h1>IME-aware Web applications</h1>
      <p>When developers develop an IME-aware web application, they need to
      decide which IME to use in their web application: JavaScript IMEs, system
      IMEs, or none. The following sections describe practices of these three
      cases.</p>
      <section id="using-js-imes">
        <h1>Using JavaScript IMEs</h1
        <p>A web application that uses only JavaScript IMEs MUST disable
        the system IMEs associated with the hosting user-agent to prevent keyboard
        events from being consumed by system IMEs. To disable the system IMEs
        associated with a user-agent, the web application MUST call
        getInputContext().setEnabled(true) and
        window.inputmethodmanager.setOpenState(false) when initializing itself
        and when it gains the focus.</p>
        <figure id="disabling-system-ime">
          <p><img height="373" src="images/image07.png" width="657"></p>
          <figcaption>Disable the system IME and enable a JavaScript IME</figcaption>
        </figure>
        <p>JavaScript IMEs MAY not dispatch keyboard events consumed by them
        to web applications. Therefore, developers should not depend on such
        keyboard events to develop their web applications when using JavaScript
        IMEs.</p>
      </section>
      <section id="using-system-imes">
        <h1>Using system IMEs</h1>
        <p>On the other hand, a web application that uses the system IME
        MUST enable the system IME when it becomes active as well as it disables
        the JavaScript IMEs. JavaScript IMEs MAY consume keyboard events even
        though the web application calls getInputContext().setEnabled(false). To
        prevent such JavaScript IMEs from consuming keyboard events, the web
        application should add event handlers to keyboard events.</p>
        <figure id="enabling-system-ime">
          <p><img height="469" src="images/image09.png" width="657"></p>
          <figcaption>Enable the system IME and disable JavaScript IMEs</figcaption>
        </figure>
      </section>
      <section id="does-not-use-imes">
        <h1>Does not use IMEs</h1>
        <p>When a web application does not use any IMEs, it…</p>
        <figure id="no-imes">
          <p><img height="305" src="images/image00.png" width="657"></p>
          <figcaption>[to come]</figcaption>
        </figure>
        </section>
      </section>
  </body>
</html>
